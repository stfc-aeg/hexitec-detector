# -*- coding: utf-8 -*-
# Copyright(c) 2023 UNITED KINGDOM RESEARCH AND INNOVATION
# Electronic System Design Group, Technology Department,
# Science and Technology Facilities Council
# Licensed under the BSD 3-Clause license. See LICENSE file in the project root for details.
"""Classes and functions for generating reusable `XML2VHDL` registers in the `RDMA` control plane.
"""
import pathlib
import xml.etree.ElementTree as ET
import json
import pprint
import datetime

class ConstantsSupportedMmaps(object):
    """A non-changing class containing XML2VHDL IC IDs to extract memory mapped registers and fields.

    Attributes:
        MEMORY_MAPS (:obj:`list` of :obj:`str`): XML2VHDL IC ID references to include when parsing XML2VHDL generated output XML.

    """
    __slots__ = ()
    MEMORY_MAPS = [
        'board_build_info',
        'hexitec_2x6',
        'qsfp_1',
        'qsfp_2',
        'vsr_fpga_regs_v0_5',
        ]

def generate_fheader():
    """Function to add standard header to generated python file.

    Returns:
        :obj:`list`: Line-by-line :obj:`str` containing header text.

    """
    today = datetime.date.today()
    fheader = list()
    fheader.append("# -*- coding: utf-8 -*-")
    fheader.append(f"# Copyright(c) {today.year} UNITED KINGDOM RESEARCH AND INNOVATION")
    fheader.append(f"# Electronic System Design Group, Technology Department,")
    fheader.append(f"# Science and Technology Facilities Council")
    fheader.append(f"# Licensed under the BSD 3-Clause license. See LICENSE file in the project root for details.")
    fheader.append("")
    fheader.append("# *** This file was AUTO-GENERATED. Modifications to this file will be overwritten. ***")
    fheader.append('"""Register dictionaries extracted from XML2VHDL formatted `xml` memory-map generation output file."""')
    return fheader


def generate_reg_docstring(reg):
    """Function to add standardised Sphinx parsable docstring for inclusion with extracted register.

    Args:
        reg (:obj:`rdma_control.MMapRegister`): Register to parse.

    Returns:
        :obj:`list`: Line-by-line :obj:`str` containing docstring text.
    """
    docstr = list()
    docstr.append(f'""":const:`{reg.name}`.')
    docstr.append("")
    docstr.extend(generate_packetdiag_header())
    if reg.fields:
        populated_entries = ([generate_packetdiag_entry(f.name, f.nof_bits, f.shiftr) for f in reg.fields])
    else:
        populated_entries = [ generate_packetdiag_entry(reg.name, reg.nof_bits, reg.shiftr) ]
    docstr.extend(pack_missing_packetdiag_bits(populated_entries, max_bits=32))
    docstr.extend(generate_packetdiag_footer())
    docstr.append("")
    docstr.append('"""')
    return docstr


def generate_packetdiag_header():
    """Function to generate a **partial** `packetdiag` Sphinx parsable domain for inclusion with extracted register.

    The output generated by this function will require at least the footer generated by
    :func:`generate_packetdiag_footer`.

    Returns:
        :obj:`list`: Line-by-line :obj:`str` containing `packetdiag` header text declaration.
    """
    hdr = list()
    hdr.append(".. packetdiag::")
    hdr.append("")
    hdr.append("   packetdiag {")
    hdr.append("      colwidth = 32")
    hdr.append("      node_height = 144")
    hdr.append("      scale_direction = right_to_left")
    hdr.append("      scale_interval = 8")
    hdr.append("")
    return hdr


def generate_packetdiag_footer():
    """Function to generate a **partial** footer to complete the `packetdiag` declaration.

    The output generated by this function is expected to be appended to a :obj:`list` generated by
    :func:`generate_packetdiag_header` and :func:`generate_packetdiag_entry`.

    Returns:
        :obj:`list`: containing a single element to terminate the `packetdiag` declaration.
    """
    return ["   }"]


def generate_packetdiag_entry(name, nof_bits, shiftr):
    """Function to generate a single register field entry to a `packetdiag` declaration.

    The output generated by this function is expected to be appended to a :obj:`list` of all entries to describe the
    complete register.

    Args:
        name (:obj:`str`): field/register name.
        nof_bits (:obj:`int`): Number of bits for the entry.
        shiftr (:obj:`int`): The position of the entry within the register.

    Returns:
        :obj:`str`: containing a single entry to add to the `packetdiag` declaration.
    """
    options = list()
    start_idx = shiftr
    end_idx = shiftr + nof_bits - 1
    if nof_bits == 1:
        idx = f"{start_idx}:"
    else:
        idx = f"{start_idx}-{end_idx}:"
    if nof_bits < 4:
        options.append("rotate = 270")
    if name.upper().startswith("RSV"):
        options.append("color = lightgrey")
    if len(options) > 0:
        extended_options = f"[ {', '.join(options)} ]"
    else:
        extended_options = ""
    entry = f"      {idx} {name} {extended_options}"
    return entry


def pack_missing_packetdiag_bits(entries, max_bits=32):
    """Function to calculate and pack empty field entries to ensure all bits are correctly added `packetdiag` declaration.

    Args:
        entries (:obj:`list`): all fields, including empty ones to describe the complete register.
        max_bits (:obj:`int`, optional): Maximum number of bits in the register. Default: `32`.

    Returns:
        :obj:`list`: containing all elements in the `packetdiag` declaration.
    """
    temp_entries = [ f"      {i}:" for i in range(0, max_bits) ]
    for e in entries:
        extracted_idx = e.strip().split(':')[0]
        if "-" in extracted_idx:
            start_idx = int(extracted_idx.split('-')[0])
            end_idx = int(extracted_idx.split('-')[1]) + 1
        else:
            start_idx = int(extracted_idx)
            end_idx = start_idx + 1
        del temp_entries[start_idx:end_idx]
        [ temp_entries.insert(i, e) for i in range(start_idx, end_idx) ]
    packed_entries = list()
    for i in temp_entries:
        if i not in packed_entries:
            packed_entries.append(i)
    empty_idxs = list()
    for i, e in enumerate(packed_entries):
        if e.strip().split(':')[1] == "":
            loc = int(packed_entries[i].strip().split(':')[0])
            d = [i, loc]
            empty_idxs.append(d)
    empty_idxs_plus_one = empty_idxs
    empty_idxs_plus_one.append([max_bits, max_bits])
    grouped_idxs = list()
    new_group = False
    for i in range(0, len(empty_idxs) - 1):
        emty_idx, actual_idx = empty_idxs[i]
        emty_idx_plus_one, actual_idx_plus_one = empty_idxs_plus_one[i+1]
        if emty_idx + 1 == emty_idx_plus_one:
            if not new_group:
                start_idx = actual_idx
                end_idx = actual_idx_plus_one
                grp_start_idx = emty_idx
                grp_end_idx = emty_idx_plus_one
                new_group = True
            else:
                end_idx = actual_idx_plus_one
                grp_end_idx = emty_idx_plus_one
        else:
            if new_group:
                grouped_idxs.append([[grp_start_idx, grp_end_idx], f"{start_idx}-{end_idx}: [ color = lightgrey ]"])
                new_group = False
            else:
                start_idx = actual_idx
                end_idx = actual_idx_plus_one
                rp_start_idx = emty_idx
                grp_end_idx = emty_idx_plus_one
                grouped_idxs.append([ [rp_start_idx, grp_end_idx], f"{actual_idx_plus_one}: [ color = lightgrey ]"])
    if grouped_idxs:
        packed_entries = compress_packetdiag_entries(packed_entries, grouped_idxs)
    # add colour option to any missed "empty" entries:
    for i, e in enumerate(packed_entries):
        if e.split(':')[1] == "":
            packed_entries[i] = f"{e} [ color = lightgrey ]"
    return packed_entries


def compress_packetdiag_entries(entries, grouped_idxs):
    """Function to compress multiple consecutive entries and replace with a single grouped entry for the `packetdiag` declaration.

    Args:
        entries (:obj:`list`): all fields, including empty ones to describe the complete register.
        grouped_idxs (:obj:`list`): each element describing the grouping and entry to be modified. In the form:
            `[ [start_idx, end_idx], entry ]`.

    Returns:
        :obj:`list`: containing all compressed entries for the `packetdiag` declaration.
    """
    grouped_idxs.reverse() # reverse list so removing later indexes first doesn't affect indexes in grouped_idxs
    for e in grouped_idxs:
        idxs = e[0]
        r = range(int(idxs[0]), int(idxs[1]) + 1)
        for i in reversed(r):
            entries[i] = f"      {e[1]}"
    compressed_entries = list()
    for i in entries:
        if i not in compressed_entries:
            compressed_entries.append(i)
    return compressed_entries


def calc_shiftr(mask):
    """Calculates the number of bits to shift right to give actual value from a given mask.

    Operates on 32 bit registers.

    Args:
        mask (:obj:`int`): The bit mask, usually returned from :mod:`rdma_control.RDMA_REGISTERS` register/field
            descriptions.

    Returns:
        :obj:`int`: The number of bits required to shift right to get the real value of the masked register/field.
    """
    shift = 0
    temp_mask = mask
    for x in range(0, 32):
        if not (mask >> x) % 2:
            temp_mask = mask >> x
        else:
            shift = x
            break
    return shift


class MMapRegister(object):
    """A class used to describe and operate on a 32 bit memory-mapped accessible register and its fields.

    Args:
        name (:obj:`str`): Name of the register extracted from XML2VHDL description.
        addr (:obj:`int`): Memory-mapped address of the register.
        reset_value (:obj:`int`, optional): Reset value of the register extracted from XML2VHDL description..
            Default: `0x0`.
        mask (:obj:`int`, optional): Mask of the register extracted from XML2VHDL description.
            Default: `0xFFFFFFFF`.
        descr (:obj:`str`, optional): Text description of the register extracted from XML2VHDL description.
            Default: `""` (empty string).

    Attributes:
        name (:obj:`str`): Name of the register extracted from XML2VHDL description.
        reset_value (:obj:`int`): Reset value of the field extracted from XML2VHDL description.
            Default: `0x0`.
        mask (:obj:`int`): Mask of the register extracted from XML2VHDL description.
            Default: `0xFFFFFFFF`.
        shiftr (:obj:`int`): The number of bits required to shift right to get the real value of the
            masked field. Default: `0`.
        description (:obj:`str`): Text description of the register extracted from XML2VHDL description.
            Default: `""` (empty string).
        fields (:obj:`list` of :obj:`MMapRegister.MMapField`, optional): All fields for the register if described in the
            XML2VHDL description. Default: :obj:`list()` (empty list).
    """
    def __init__(self, name, addr, reset_value=0x0, mask=0xFFFFFFFF, descr=""):
        self.name = name
        self.addr = int(addr, 16)
        self.reset_value = reset_value
        self.mask = int(mask, 16)
        self.shiftr = calc_shiftr(self.mask)
        self.nof_bits = (self.mask >> self.shiftr).bit_length()
        self.description = descr
        self.fields = list()

    def get_info(self, extended=False):
        """Prints memory-map information, extracted from :obj:`MMapRegister`.

        Args:
            extended (:obj:`bool`, optional): Included description in returned info. Default: `False`.

        Returns:
            Nothing.
        """
        fields = [ f.name for f in self.fields ]
        addr = f"0x{self.addr:08X}"
        print(f"[{self.name}]: Address: {addr} | Fields: {fields} | Reset: {self.reset_value}")
        if extended:
            print(f"     Description: <{self.description}>")

    def get_field_info(self, extended=False):
        """Prints memory-map field information, extracted from :obj:`MMapRegister.MMapField`.

        Returns information on all found fields.

        Args:
            extended (:obj:`bool`, optional): Included description in returned info. Default: `False`.

        Returns:
            Nothing.
        """
        if self.fields:
            print(f"[{self.name}]:")
            for f in self.fields:
                mask = f"0x{f.mask:08X}"
                print(f"    [{f.name}]: Mask: {mask} <{f.shiftr}> | Size (bits): {f.nof_bits} | Reset: {f.reset_value}")
                if extended:
                    print(f"     Description: <{f.description}>")
        else:
            print(f"[{self.name}]: <no fields>")

    def add_field(self, name, reset_value, mask, descr):
        """Adds a new :obj:`MMapRegister.MMapField` to the :attr:`fields` :obj:`list`.

        Args:
            name (:obj:`str`): Name of the register usually extracted from XML2VHDL description.
            reset_value (:obj:`int`): Reset value of the field usually extracted from XML2VHDL description.
            mask (:obj:`int`): Mask of the register usually extracted from XML2VHDL description.
            descr (:obj:`str`): Text description of the register usually extracted from XML2VHDL description.

        Returns:
            Nothing.
        """
        self.fields.append(self.MMapField(name, reset_value, mask, descr))

    def get_field(self, name):
        """Returns the :obj:`MMapRegister.MMapField` for the given field name.

        Args:
            name (:obj:`str`): Name of field to fetch.

        Returns:
            :obj:`MMapRegister.MMapField` if found, otherwise `None`.
        """
        for f in self.fields:
            if f.name.upper() == name.upper():
                return f
        else:
            return None

    def decode_field(self, field, d):
        """Decodes a data word, usually returned from a register read operation, and returns value of the given field.

        The data word will be ANDed with the :attr:`MMapField.mask` attribute and shifted right by the
        :attr:`MMapField.shiftr` attribute value.

        Args:
            field (:obj:`str`): name of register field to decode.
            d (:obj:`int`): data word to extract and decode field value from.

        Returns:
            :obj:`int`: decoded value if :attr:`field` exists, otherwise: `None`

        """
        f = self.get_field(field)
        if f is not None:
            return (d & f.mask) >> f.shiftr
        else:
            return None

    def encode_field(self, field, v):
        """Encodes a value by positioning the value into the correct mask position for a given field.

        Args:
            field (:obj:`str`): name of register field to decode.
            v (:obj:`int`): value to encode into the correct mask position.

        Returns:
            :obj:`int`: encoded value if :attr:`field` exists, otherwise: `None`

        """
        f = self.get_field(field)
        if f is not None:
            return f.mask & (v << f.shiftr)
        else:
            return None

    def set_field(self, field, d, v):
        """Sets a field value into the correct mask position within a given data word, usually returned from a register read operation.

        Args:
            field (:obj:`str`): name of register field to decode.
            d (:obj:`int`): data word to modify.
            v (:obj:`int`): value to encode into the correct mask position.

        Returns:
            :obj:`int`: modified value of :attr:`d` if :attr:`field` exists, otherwise: `None`

        """
        return self.encode_field(field, v) | self.clr_field(field, d)

    def clr_field(self, field, d):
        """Clears a field value within a given data word, usually returned from a register read operation.

        Args:
            field (:obj:`str`): name of register field to decode.
            d (:obj:`int`): data word to modify.

        Returns:
            :obj:`int`: modified value of :attr:`d` if :attr:`field` exists, otherwise: `None`

        """
        return  d & ~self.encode_field(field, 0xFFFFFFFF)

    class MMapField(object):
        """A subclass to describe and operate on register fields.

        Args:
            name (:obj:`str`): Name of the field extracted from XML2VHDL field description.
            reset_value (:obj:`int`, optional): Reset value of the field extracted from XML2VHDL field description.
                Default: `0x0`.
            mask (:obj:`int`, optional): Mask of the field extracted from XML2VHDL field description.
                Default: `0xFFFFFFFF`.
            descr (:obj:`str`, optional): Text description of the field extracted from XML2VHDL field.
                Default: `""` (empty string).

        Attributes:
            name (:obj:`str`): Name of the field extracted from XML2VHDL field description.
            reset_value (:obj:`int`): Reset value of the field extracted from XML2VHDL field description.
                Default: `0x0`.
            mask (:obj:`int`): Mask of the field extracted from XML2VHDL field description.
                Default: `0xFFFFFFFF`.
            shiftr (:obj:`int`): The number of bits required to shift right to get the real value of the
                masked register/field. Default: `0`.
            description (:obj:`str`): Text description of the field extracted from XML2VHDL field.
                Default: `""` (empty string).
            nof_bits (:obj:`int`): Number of bits used by the register field.
            is_bit (:obj:`bool`): Flag to indicate if bit field operations can be performed on this XML2VHDL field.

        """
        def __init__(self, name, reset_value=0x0, mask=0xFFFFFFFF, descr=""):
            self.name = name
            self.reset_value = reset_value
            self.mask = int(mask, 16)
            self.shiftr = calc_shiftr(self.mask)
            self.description = descr
            self.nof_bits = (self.mask >> self.shiftr).bit_length()
            self.is_bit = True if self.nof_bits == 1 else False


def load_memory_maps(input_file):
    """Function to load supported memory maps from XML2VHDL generated output XML file.

    See :class:`rdma_control.RdmaXml2Vhdl.ConstantsSupportedMmaps` for supported memory maps.

    """
    supported_mmaps = ConstantsSupportedMmaps()
    xml_output = ET.parse(str(input_file.resolve()))
    top_level = xml_output.getroot()
    registers = list()

    for node in top_level:
        try:
            node_id = node.attrib['absolute_id'].split('.')[1]
            print(f"node_id = {node_id}")
        except KeyError as e:
            print(e)
            [print(f"    [{k}]: {v}") for k, v in node.attrib.items()]
            input()
        if node_id in supported_mmaps.MEMORY_MAPS:
            for child in node:
                child_id = ('_'.join(child.attrib['absolute_id'].split('.')[1:])).upper()
                addr = f"0x{child.attrib['absolute_offset']}"
                if child.attrib['hw_rst'].lower() == "no":
                    hw_rst = None
                else:
                    hw_rst = child.attrib['hw_rst']
                try:
                    reg_mask = child.attrib['mask']
                except KeyError:
                    reg_mask = "0xFFFFFFFF"
                description=child.attrib['description']
                globals()[child_id] = MMapRegister(child_id, addr, hw_rst, reg_mask, description)
                if len(child) > 0:
                    for field in child:
                        name = (field.attrib['absolute_id'].split('.')[-1]).upper()
                        mask = field.attrib['mask']
                        if field.attrib['hw_rst'].lower() == "no":
                            rst = None
                        else:
                            rst = field.attrib['hw_rst']
                        description=field.attrib['description']
                        globals()[child_id].add_field(name, rst, mask, description)
                registers.append(globals()[child_id])
    return registers


def mmapobj2dict(mmapobj):
    new_dict = dict()
    excl_attrs = ("MMapField", "get_", "clr_", "encode_", "decode_", "add_", "set_", "__")
    attrs = [attr for attr in dir(mmapobj) if not attr.startswith(excl_attrs)]
    for k in attrs:
        new_dict[k] = getattr(mmapobj, k)
    # replace the extracted fields key with an empty list, ready to re-populated with a dict per field rather than mmapfieldobj
    new_dict['fields'] = list()
    if mmapobj.fields:
        for mmapfieldobj in mmapobj.fields:
            f_attrs = [f_attr for f_attr in dir(mmapfieldobj) if not f_attr.startswith(excl_attrs)]
            new_field_dict = dict()
            for k in f_attrs:
                new_field_dict[k] = getattr(mmapfieldobj, k)
            new_dict['fields'].append(new_field_dict)
    return new_dict


def export_decl_file(input_file, output_file):
    """Exports python file declaring dictionary descriptions of registers extracted from XML input file.

    Args:
        input_file(:obj:`pathlib`): Full path, including filename, of the `xml` file to parse registers from.
        output_file(:obj:`pathlib`): Full path, including filename, of the `py` file to export.

        Returns:
            Nothing.
    """
    pp = pprint.PrettyPrinter(indent=2)
    registers = load_memory_maps(input_file)
    with output_file.open(mode="w") as fp:
        [fp.write(f"{line}\n") for line in generate_fheader()]
        for reg in registers:
            reg_declaration = f"{reg.name} = {pp.pformat(mmapobj2dict(reg))}"
            fp.write(reg_declaration + "\n")
            [fp.write(f"{line}\n") for line in generate_reg_docstring(reg)]
            fp.write("\n")


if __name__ == '__main__':

    generated_xml_path = "../../../../src/vhdl/generated/"
    top_generated_xml_fname = "hex2x6_ic_memory_map_output.xml"
    generated_output_path = "./"
    generated_output_fname = "RDMA_REGISTERS.py"
    generated_mmap_xml_output = pathlib.Path.cwd() / generated_xml_path / top_generated_xml_fname
    generated_rdma_py_output = pathlib.Path.cwd() / generated_output_path / generated_output_fname
    export_decl_file(input_file=generated_mmap_xml_output, output_file=generated_rdma_py_output)

    generated_xml_path = "../../../../src/xml/"
    top_generated_xml_fname = "vsr_fpga_regs_v0_5_memory_map.xml"
    generated_output_path = "./"
    generated_output_fname = "VSR_FPGA_REGISTERS.py"
    generated_vsr_fpga_reg_xml_output = pathlib.Path.cwd() / generated_xml_path / top_generated_xml_fname
    generated_vsr_fpga_reg_py_output = pathlib.Path.cwd() / generated_output_path / generated_output_fname
    export_decl_file(input_file=generated_vsr_fpga_reg_xml_output, output_file=generated_vsr_fpga_reg_py_output)
